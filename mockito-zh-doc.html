<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>Mockito 3.6.0 中文文档 - ChangingFond</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ChangingFond"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ChangingFond"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Mockito 库能够 Mock 对象、验证结果以及打桩(stubbing)。本中文文档基于 Mockito 3.6.0 版本的官方文档翻译，如有错误，欢迎在评论区指正👏。"><meta property="og:type" content="blog"><meta property="og:title" content="Mockito 3.6.0 中文文档"><meta property="og:url" content="http://blog.fcj.one/mockito-zh-doc.html"><meta property="og:site_name" content="ChangingFond"><meta property="og:description" content="Mockito 库能够 Mock 对象、验证结果以及打桩(stubbing)。本中文文档基于 Mockito 3.6.0 版本的官方文档翻译，如有错误，欢迎在评论区指正👏。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://blog.fcj.one/img/og_image.png"><meta property="article:published_time" content="2020-10-28T23:32:43.000Z"><meta property="article:modified_time" content="2022-04-29T07:03:48.312Z"><meta property="article:author" content="ChangingFond"><meta property="article:tag" content="Java"><meta property="article:tag" content="Mockito"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.fcj.one/mockito-zh-doc.html"},"headline":"Mockito 3.6.0 中文文档","image":["http://blog.fcj.one/img/og_image.png"],"datePublished":"2020-10-28T23:32:43.000Z","dateModified":"2022-04-29T07:03:48.312Z","author":{"@type":"Person","name":"ChangingFond"},"publisher":{"@type":"Organization","name":"ChangingFond","logo":{"@type":"ImageObject","url":"http://blog.fcj.one/img/avatar.png"}},"description":"Mockito 库能够 Mock 对象、验证结果以及打桩(stubbing)。本中文文档基于 Mockito 3.6.0 版本的官方文档翻译，如有错误，欢迎在评论区指正👏。"}</script><link rel="canonical" href="http://blog.fcj.one/mockito-zh-doc.html"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github-gist.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?5c015a03c13b91e23ae1a852dd15b00d";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer="defer"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="ChangingFond" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ChangingFond"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-10-28T23:32:43.000Z" title="10/28/2020, 11:32:43 PM">2020-10-28</time>发表</span><span class="level-item"><time datetime="2022-04-29T07:03:48.312Z" title="4/29/2022, 7:03:48 AM">2022-04-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">编程笔记</a></span><span class="level-item">1 小时读完 (约8999字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Mockito 3.6.0 中文文档</h1><div class="content"><p><a target="_blank" rel="noopener" href="http://mockito.org/">Mockito</a> 库能够 Mock 对象、验证结果以及打桩(stubbing)。<br>本中文文档基于 Mockito 3.6.0 版本的<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html">官方文档</a>翻译，如有错误，欢迎在评论区指正👏。</p><span id="more"></span><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol start="0"><li><a href="#0">迁移到Mockito 2.0</a></li><li><a href="#1">验证某些行为</a></li><li><a href="#2">如何做一些测试桩 (Stub)</a></li><li><a href="#3">参数匹配器 (matchers)</a></li><li><a href="#4">验证函数的确切、最少、从未调用次数</a></li><li><a href="#5">为返回值为void的函数通过Stub抛出异常</a></li><li><a href="#6">按照顺序验证执行结果</a></li><li><a href="#7">确保交互(interaction)操作不会执行在mock对象上</a></li><li><a href="#8">查找冗余的调用</a></li><li><a href="#9">简化mock对象的创建</a></li><li><a href="#10">为连续的调用做测试桩 (stub)</a></li><li><a href="#11">为回调做测试桩</a></li><li><a href="#12">doReturn()、doThrow()、doAnswer()、doNothing()、doCallRealMethod()系列方法的运用</a></li><li><a href="#13">监控真实对象</a></li><li><a href="#14">修改没有测试桩的调用的默认返回值 ( 1.7版本之后 )</a></li><li><a href="#15">为下一步的断言捕获参数 (1.8版本之后)</a></li><li><a href="#16">真实的局部mocks (1.8版本之后)</a></li><li><a href="#17">重置mocks对象 (1.8版本之后)</a></li><li><a href="#18">故障排查与验证框架的使用 (1.8版本之后)</a></li><li><a href="#19">行为驱动开发的别名 (1.8版本之后)</a></li><li><a href="#20">序列化mock对象</a></li><li><a href="#21">新的注解 : @Captor,@Spy,@ InjectMocks (1.8.3版本之后)</a></li><li><a href="#22">验证超时 (1.8.5版本之后)</a></li><li><a href="#23">自动初始化被@Spies, @InjectMocks注解的字段以及构造函数注入 (1.9.0版本之后)</a></li><li><a href="#24">单行测试桩 (1.9.0版本之后)</a></li><li><a href="#25">验证被忽略的测试桩 (1.9.0版本之后)</a></li><li><a href="#26">mock详情 (1.9.5版本之后)</a></li><li><a href="#27">delegate调用真实的实例 (1.9.5版本之后)</a></li><li><a href="#28">MockMaker API (1.9.5版本之后)</a></li><li><a href="#29">BDD风格的验证 (1.10.0版本之后)</a></li><li><a href="#30">追踪或者Mock抽象类 (1.10.12版本之后)</a></li><li><a href="#31">Mockito mock对象通过ClassLoader能被序列化/反序列化 (1.10.0版本之后)</a></li><li><a href="#32">deep stubs更好的支持泛型 (1.10.0版本之后)</a></li><li><a href="#33">Mockito JUnit 规则 (1.10.17版本之后)</a></li><li><a href="#34">开/关插件 (1.10.15版本之后)</a></li><li><a href="#35">自定义验证失败消息 (2.0.0版本之后)</a></li></ol><h2 id="0-迁移到-Mockito-2-0"><a href="#0-迁移到-Mockito-2-0" class="headerlink" title="0. 迁移到 Mockito 2.0"></a>0. 迁移到 Mockito 2.0</h2><p>为了持续提升 Mockito 以及更进一步的提升单元测试体验，我们希望你升级到 Mockito 2.1.0。Mockito 遵循语意化的版本控制，除非有非常大的改变才会变化主版本号。在一个库的生命周期中，为了引入一系列有用的特性，修改已存在的行为或者 API 等重大变更是在所难免的。有关新版本（包括不兼容的更改）的全面指南，请参阅”Mockito 2” <a target="_blank" rel="noopener" href="https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2">wiki 页面</a>中的 “What’s new in Mockito 2”。我们希望你能够喜欢 Mockito 2.0!</p><p>0.1. Mockito Android support<br>With Mockito version 2.6.1 we ship “native” Android support. To enable Android support, add the <code>mockito-android</code> library as dependency to your project. This artifact is published to the same Mockito organization and can be imported for Android as follows: You can continue to run the same unit tests on a regular VM by using the <code>mockito-core</code> artifact in your “testCompile” scope as shown above. Be aware that you cannot use the inline mock maker on Android due to limitations in the Android VM. If you encounter issues with mocking on Android, please open an issue on the official issue tracker. Do provide the version of Android you are working on and dependencies of your project.</p><p>0.2. Configuration-free inline mock making<br>Starting with version 2.7.6, we offer the ‘mockito-inline’ artifact that enables inline mock making without configuring the MockMaker extension file. To use this, add the <code>mockito-inline</code> instead of the <code>mockito-core</code> artifact as follows: Be aware that this artifact may be abolished when the inline mock making feature is integrated into the default mock maker.</p><h2 id="1-验证某些行为"><a href="#1-验证某些行为" class="headerlink" title="1. 验证某些行为"></a>1. 验证某些行为</h2><p>跟着我们的示例来 mock 一个 List，因为大家对 List 接口很熟悉（例如 add(),get(), clear()）。事实上，不要 mock List 接口本身,而要使用 List 的一个实例来替代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态导入会使代码更简洁</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 mock 对象</span></span><br><span class="line"><span class="type">List</span> <span class="variable">mockedList</span> <span class="operator">=</span> mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 mock 对象</span></span><br><span class="line">mockedList.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">mockedList.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line">verify(mockedList).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">verify(mockedList).clear();</span><br></pre></td></tr></table></figure><p>一旦 mock 对象被创建了，mock 对象会记住所有的交互。然后你就可能选择性地验证你感兴趣的交互。</p><h2 id="2-如何做一些测试桩-Stub"><a href="#2-如何做一些测试桩-Stub" class="headerlink" title="2. 如何做一些测试桩 (Stub)"></a>2. 如何做一些测试桩 (Stub)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你可以 mock 具体的类型，不仅只是接口</span></span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">mockedList</span> <span class="operator">=</span> mock(LinkedList.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试桩</span></span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出“first”</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 get(999) 没有打桩，因此输出 null</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Although it is possible to verify a stubbed invocation, usually it&#x27;s just redundant</span></span><br><span class="line"><span class="comment">//If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).</span></span><br><span class="line"><span class="comment">//If your code doesn&#x27;t care what get(0) returns then it should not be stubbed. Not convinced? See here.</span></span><br><span class="line"><span class="comment">// 验证 get(0) 被调用的次数</span></span><br><span class="line">verify(mockedList).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>默认情况下，所有的函数都有返回值。mock 函数默认返回的是 null，一个空的集合或者一个被对象类型包装的内置类型，例如 0、false 对应的对象类型为 Integer、Boolean；</li><li>测试桩函数可以被覆写：例如常见的测试桩函数可以用于初始化夹具，但是测试函数能够覆写它。请注意，覆写测试桩函数是一种可能存在潜在问题的做法；</li><li>一旦测试桩函数被调用，该函数将会一直返回固定的值；</li><li>上一次调用测试桩函数有时候极为重要——当你调用一个函数很多次时，最后一次调用可能是你所感兴趣的。</li></ul><h2 id="3-参数匹配器-matchers"><a href="#3-参数匹配器-matchers" class="headerlink" title="3. 参数匹配器 (matchers)"></a>3. 参数匹配器 (matchers)</h2><p>Mockito 以自然的 java 风格来验证参数值: 使用 equals() 函数。有时当需要额外的灵活性时你可能需要使用参数匹配器 argument matchers :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用内置的 anyInt() 参数匹配器</span></span><br><span class="line">when(mockedList.get(anyInt())).thenReturn(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义的参数匹配器( 在isValid() 函数中返回你自己的匹配器实现 )</span></span><br><span class="line">when(mockedList.contains(argThat(isValid()))).thenReturn(<span class="string">&quot;element&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 element</span></span><br><span class="line">System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以验证参数匹配器</span></span><br><span class="line">verify(mockedList).get(anyInt());</span><br></pre></td></tr></table></figure><p>参数匹配器使验证和测试桩变得更灵活。<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Matchers.html">点击这里</a>查看更多内置的匹配器以及自定义参数匹配器或者 hamcrest 匹配器的示例。</p><p>如果仅仅是获取自定义参数匹配器的信息，查看<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/ArgumentMatcher.html">ArgumentMatcher类文档</a>即可。</p><p>为了合理的使用复杂的参数匹配，使用 equals() 与 anyX() 的匹配器会使得测试代码更简洁、简单。<br>有时，会迫使你重构代码以使用 equals() 匹配或者实现 equals() 函数来帮助你进行测试。<br>同时建议你阅读<a href="#15">第15章节</a>或者<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/ArgumentCaptor.html">ArgumentCaptor类文档</a>。ArgumentCaptor 是一个能够捕获参数值的特殊参数匹配器。</p><p>参数匹配器的注意点 :</p><p>如果你使用参数匹配器，所有参数都必须由匹配器提供。</p><p>示例 : ( 该示例展示了如何多次应用于测试桩函数的验证 )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">verify(mock).someMethod(anyInt(), anyString(), eq(<span class="string">&quot;third argument&quot;</span>));</span><br><span class="line"><span class="comment">// 上述代码是正确的，因为 eq() 也是一个参数匹配器</span></span><br><span class="line"></span><br><span class="line">verify(mock).someMethod(anyInt(), anyString(), <span class="string">&quot;third argument&quot;</span>);</span><br><span class="line"><span class="comment">// 上述代码是错误的，因为所有参数必须由匹配器提供，而参数 &quot;third argument&quot; 并非由参数匹配器提供，因此会抛出异常</span></span><br></pre></td></tr></table></figure><p>像 anyObject(), eq() 这样的匹配器函数不会返回匹配器。它们会在内部将匹配器记录到一个栈当中，并且返回一个假的值，通常为null。<br><code>这样的实现是由于被Java编译器强加的静态类型安全</code>。结果就是你不能在验证或者测试桩函数之外使用 anyObject(), eq() 函数。</p><p><b id="4"></b></p><h2 id="4-验证函数的确切、最少、从未调用次数"><a href="#4-验证函数的确切、最少、从未调用次数" class="headerlink" title="4. 验证函数的确切、最少、从未调用次数"></a>4. <a href="">验证函数的确切、最少、从未调用次数</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mockedList.add(<span class="string">&quot;once&quot;</span>);</span><br><span class="line"></span><br><span class="line">mockedList.add(<span class="string">&quot;twice&quot;</span>);</span><br><span class="line">mockedList.add(<span class="string">&quot;twice&quot;</span>);</span><br><span class="line"></span><br><span class="line">mockedList.add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line">mockedList.add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line">mockedList.add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的两个验证函数效果一样，因为 verify 默认验证的就是 times(1)</span></span><br><span class="line">verify(mockedList).add(<span class="string">&quot;once&quot;</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">&quot;once&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证具体的执行次数</span></span><br><span class="line">verify(mockedList, times(<span class="number">2</span>)).add(<span class="string">&quot;twice&quot;</span>);</span><br><span class="line">verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用never()进行验证,never相当于times(0)</span></span><br><span class="line">verify(mockedList, never()).add(<span class="string">&quot;never happened&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用atLeast()/atMost()</span></span><br><span class="line">verify(mockedList, atMostOnce()).add(<span class="string">&quot;once&quot;</span>);</span><br><span class="line">verify(mockedList, atLeastOnce()).add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line">verify(mockedList, atLeast(<span class="number">2</span>)).add(<span class="string">&quot;five times&quot;</span>);</span><br><span class="line">verify(mockedList, atMost(<span class="number">5</span>)).add(<span class="string">&quot;three times&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>verify 函数默认验证的是执行了 times(1)，也就是某个测试函数是否执行了 1 次。因此，times(1) 通常被省略了。</p><p><b id="5"></b></p><h2 id="5-为返回值为void的函数通过Stub抛出异常"><a href="#5-为返回值为void的函数通过Stub抛出异常" class="headerlink" title="5. 为返回值为void的函数通过Stub抛出异常"></a>5. <a href="">为返回值为void的函数通过Stub抛出异常</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockedList).clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这句代码会抛出异常</span></span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure><p>关于 doThrow | doAnswer 等函数的信息请阅读<a href="#12">第 12 节</a>。</p><p><b id="6"></b></p><h2 id="6-验证执行执行顺序"><a href="#6-验证执行执行顺序" class="headerlink" title="6. 验证执行执行顺序"></a>6. <a href="">验证执行执行顺序</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A. 验证 mock 一个对象的函数执行顺序</span></span><br><span class="line"><span class="type">List</span> <span class="variable">singleMock</span> <span class="operator">=</span> mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 singleMock</span></span><br><span class="line">singleMock.add(<span class="string">&quot;was added first&quot;</span>);</span><br><span class="line">singleMock.add(<span class="string">&quot;was added second&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为该 mock 对象创建一个 inOrder 对象</span></span><br><span class="line"><span class="type">InOrder</span> <span class="variable">inOrder</span> <span class="operator">=</span> inOrder(singleMock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保 add 函数首先执行的是 add(&quot;was added first&quot;)，然后才是 add(&quot;was added second&quot;)</span></span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">&quot;was added first&quot;</span>);</span><br><span class="line">inOrder.verify(singleMock).add(<span class="string">&quot;was added second&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B. 验证多个 mock 对象的函数执行顺序</span></span><br><span class="line"><span class="type">List</span> <span class="variable">firstMock</span> <span class="operator">=</span> mock(List.class);</span><br><span class="line"><span class="type">List</span> <span class="variable">secondMock</span> <span class="operator">=</span> mock(List.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 mock</span></span><br><span class="line">firstMock.add(<span class="string">&quot;was called first&quot;</span>);</span><br><span class="line">secondMock.add(<span class="string">&quot;was called second&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为这两个 mock 对象创建 inOrder 对象</span></span><br><span class="line"><span class="type">InOrder</span> <span class="variable">inOrder</span> <span class="operator">=</span> inOrder(firstMock, secondMock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证它们的执行顺序</span></span><br><span class="line">inOrder.verify(firstMock).add(<span class="string">&quot;was called first&quot;</span>);</span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">&quot;was called second&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A 和 B 可以按照你的意愿组合在一起</span></span><br></pre></td></tr></table></figure><p>验证执行顺序是非常灵活的：你不需要一个一个的验证所有交互，只需要验证你感兴趣的对象即可。<br>另外，你可以仅通过那些需要验证顺序的 mock 对象来创建 InOrder 对象。</p><p><b id="7"></b></p><h2 id="7-确保交互-interaction-操作不会执行在-mock-对象上"><a href="#7-确保交互-interaction-操作不会执行在-mock-对象上" class="headerlink" title="7. 确保交互(interaction)操作不会执行在 mock 对象上"></a>7. 确保交互(interaction)操作不会执行在 mock 对象上</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Mock 对象</span></span><br><span class="line">mockOne.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通验证</span></span><br><span class="line">verify(mockOne).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证某个交互是否从未被执行</span></span><br><span class="line">verify(mockOne, never()).add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 mock 对象没有交互过</span></span><br><span class="line">verifyZeroInteractions(mockTwo, mockThree);</span><br></pre></td></tr></table></figure><p><b id="8"></b></p><h2 id="8-查找冗余的调用"><a href="#8-查找冗余的调用" class="headerlink" title="8. 查找冗余的调用"></a>8. 查找冗余的调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 mock</span></span><br><span class="line">mockedList.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">mockedList.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"></span><br><span class="line">verify(mockedList).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的验证将会失败</span></span><br><span class="line">verifyNoMoreInteractions(mockedList);</span><br></pre></td></tr></table></figure><p>一些用户可能会在频繁地使用 <code>verifyNoMoreInteractions()</code>，甚至在每个测试函数中都用。但是 <code>verifyNoMoreInteractions()</code> 并不建议在每个测试函数中都使用。<code>verifyNoMoreInteractions()</code> 在交互测试套件中只是一个便利的验证，它的作用是当你需要验证是否存在冗余调用时。滥用它将导致测试代码的可维护性降低。</p><p><code>never()</code> 是一种更为明显且易于理解的形式。</p><p><b id="9"></b></p><h2 id="9-简化-mock-对象的创建-Mock-注解"><a href="#9-简化-mock-对象的创建-Mock-注解" class="headerlink" title="9. 简化 mock 对象的创建 - @Mock 注解"></a>9. 简化 mock 对象的创建 - @Mock 注解</h2><ul><li>最小化重复的创建代码</li><li>使测试类的代码可读性更高</li><li>使验证错误更易于阅读，因为字段名可用于标识 mock 对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleManagerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Mock</span> <span class="keyword">private</span> ArticleCalculator calculator;</span><br><span class="line">   <span class="meta">@Mock</span> <span class="keyword">private</span> ArticleDatabase database;</span><br><span class="line">   <span class="meta">@Mock</span> <span class="keyword">private</span> UserProvider userProvider;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ArticleManager manager;</span><br></pre></td></tr></table></figure><p>注意！下面这句代码需要在运行测试函数之前被调用，一般放到测试类的基类或者 test runner 中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MockitoAnnotations.initMocks(testClass);</span><br></pre></td></tr></table></figure><p>你可以使用内置的 runner: [MockitoJUnitRunner] [runner] 或者一个 rule : <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoJUnit.html#rule()">MockitoRule</a>。<br>对于 JUnit5 测试，在 45 节有描述。<br>关于 mock 注解的更多信息可以阅读 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html">MockitoAnnotations文档</a>。</p><p><b id="10"></b></p><h2 id="10-为连续的调用做测试桩-stub"><a href="#10-为连续的调用做测试桩-stub" class="headerlink" title="10. 为连续的调用做测试桩 (stub)"></a>10. 为连续的调用做测试桩 (stub)</h2><p>有时我们需要为同一个函数调用的不同的返回值或异常做测试桩。典型的运用就是使用 mock 迭代器。<br>原始版本的 Mockito 并没有这个特性，例如，可以使用 Iterable 或者简单的集合来替换迭代器。这些方法提供了更原始的方式。<br>在一些场景中为连续的调用做测试桩会很有用。示例如下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">when(mock.someMethod(<span class="string">&quot;some arg&quot;</span>))</span><br><span class="line">  .thenThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>())</span><br><span class="line">  .thenReturn(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用 : 抛出运行时异常</span></span><br><span class="line">mock.someMethod(<span class="string">&quot;some arg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次调用 : 输出 &quot;foo&quot;</span></span><br><span class="line">System.out.println(mock.someMethod(<span class="string">&quot;some arg&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续调用 : 也是输出 &quot;foo&quot;</span></span><br><span class="line">System.out.println(mock.someMethod(<span class="string">&quot;some arg&quot;</span>));</span><br></pre></td></tr></table></figure><p>另外，连续调用的另一种更简短的版本 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次调用时返回 &quot;one&quot;，第二次返回 &quot;two&quot;，第三次返回 &quot;three&quot;</span></span><br><span class="line"> when(mock.someMethod(<span class="string">&quot;some arg&quot;</span>))</span><br><span class="line">   .thenReturn(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br></pre></td></tr></table></figure><p><b id="11"></b></p><h2 id="11-为回调做测试桩"><a href="#11-为回调做测试桩" class="headerlink" title="11. 为回调做测试桩"></a>11. 为回调做测试桩</h2><p>Allows stubbing with generic Answer interface.<br>运行为泛型接口 Answer 打桩。</p><p>在最初的Mockito里也没有这个具有争议性的特性。我们建议使用thenReturn() 或thenThrow()来打桩。这两种方法足够用于测试或者测试驱动开发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">when(mock.someMethod(anyString())).thenAnswer(<span class="keyword">new</span> <span class="title class_">Answer</span>() &#123;</span><br><span class="line">    Object <span class="title function_">answer</span><span class="params">(InvocationOnMock invocation)</span> &#123;</span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">mock</span> <span class="operator">=</span> invocation.getMock();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;called with arguments: &quot;</span> + args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Following prints &quot;called with arguments: foo&quot;</span></span><br><span class="line"><span class="comment">// 输出 : &quot;called with arguments: foo&quot;</span></span><br><span class="line">System.out.println(mock.someMethod(<span class="string">&quot;foo&quot;</span>));</span><br></pre></td></tr></table></figure><p><b id="12"></b></p><h2 id="12-doReturn-、doThrow-、doAnswer-、doNothing-、doCallRealMethod-系列方法的运用"><a href="#12-doReturn-、doThrow-、doAnswer-、doNothing-、doCallRealMethod-系列方法的运用" class="headerlink" title="12. doReturn()、doThrow()、doAnswer()、doNothing()、doCallRealMethod()系列方法的运用"></a>12. <a href="">doReturn()、doThrow()、doAnswer()、doNothing()、doCallRealMethod()系列方法的运用</a></h2><p>通过<code>when(Object)</code>为无返回值的函数打桩有不同的方法,因为编译器不喜欢void函数在括号内…</p><p>使用<code>doThrow(Throwable)</code> 替换<code>stubVoid(Object)</code>来为void函数打桩是为了与<code>doAnswer()</code>等函数族保持一致性。</p><p>当你想为void函数打桩时使用含有一个exception 参数的<code>doAnswer()</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockedList).clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//following throws RuntimeException:</span></span><br><span class="line"><span class="comment">// 下面的代码会抛出异常</span></span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure><p>当你调用<code>doThrow()</code>, <code>doAnswer()</code>, <code>doNothing()</code>, <code>doReturn()</code> and <code>doCallRealMethod()</code> 这些函数时可以在适当的位置调用<code>when()</code>函数. 当你需要下面这些功能时这是必须的:</p><ul><li>测试void函数</li><li>在受监控的对象上测试函数</li><li>不知一次的测试为同一个函数，在测试过程中改变mock对象的行为。</li></ul><p>但是在调用<code>when()</code>函数时你可以选择是否调用这些上述这些函数。</p><p>阅读更多关于这些方法的信息:</p><ul><li><a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doReturn(java.lang.Object">doReturn(Object)</a>)</li><li><a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doThrow(java.lang.Throwable">doThrow(Throwable)</a>)</li><li><a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doThrow(java.lang.Class">doThrow(Class)</a>)</li><li><a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doAnswer(org.mockito.stubbing.Answer">doAnswer(Answer)</a>)</li><li><a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doNothing(">doNothing()</a>)</li><li><a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doCallRealMethod(">doCallRealMethod()</a>)</li></ul><p><b id="13"></b></p><h2 id="13-监控真实对象"><a href="#13-监控真实对象" class="headerlink" title="13. 监控真实对象"></a>13. <a href="">监控真实对象</a></h2><p>你可以为真实对象创建一个监控(spy)对象。当你使用这个spy对象时真实的对象也会也调用，除非它的函数被stub了。尽量少使用spy对象，使用时也需要小心形式，例如spy对象可以用来处理遗留代码。</p><p>监控一个真实的对象可以与“局部mock对象”概念结合起来。在1.8之前，mockito的监控功能并不是真正的局部mock对象。原因是我们认为局部mock对象的实现方式并不好，在某些时候我发现一些使用局部mock对象的合法用例。（第三方接口、临时重构遗留代码，完整的文章在<a target="_blank" rel="noopener" href="http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring/">这里</a> ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="type">List</span> <span class="variable">spy</span> <span class="operator">=</span> spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//optionally, you can stub out some methods:</span></span><br><span class="line"><span class="comment">// 你可以为某些函数打桩</span></span><br><span class="line">when(spy.size()).thenReturn(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//using the spy calls *real* methods</span></span><br><span class="line"><span class="comment">// 通过spy对象调用真实对象的函数</span></span><br><span class="line">spy.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">spy.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//prints &quot;one&quot; - the first element of a list</span></span><br><span class="line"><span class="comment">// 输出第一个元素</span></span><br><span class="line">System.out.println(spy.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//size() method was stubbed - 100 is printed</span></span><br><span class="line"><span class="comment">// 因为size()函数被打桩了,因此这里返回的是100</span></span><br><span class="line">System.out.println(spy.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//optionally, you can verify</span></span><br><span class="line"><span class="comment">// 交互验证</span></span><br><span class="line">verify(spy).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">verify(spy).add(<span class="string">&quot;two&quot;</span>);</span><br></pre></td></tr></table></figure><p>理解监控真实对象非常重要！</p><p>有时，在监控对象上使用<code>when(Object)</code>来进行打桩是不可能或者不切实际的。因此，当使用监控对象时请考虑<code>doReturn|Answer|Throw()</code>函数族来进行打桩。例如 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="type">List</span> <span class="variable">spy</span> <span class="operator">=</span> spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)</span></span><br><span class="line"><span class="comment">// 不可能 : 因为当调用spy.get(0)时会调用真实对象的get(0)函数,此时会发生IndexOutOfBoundsException异常，因为真实List对象是空的</span></span><br><span class="line">   when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//You have to use doReturn() for stubbing</span></span><br><span class="line"><span class="comment">// 你需要使用doReturn()来打桩</span></span><br><span class="line">doReturn(<span class="string">&quot;foo&quot;</span>).when(spy).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>Mockito并不会为真实对象代理函数调用，实际上它会拷贝真实对象。因此如果你保留了真实对象并且与之交互，不要期望从监控对象得到正确的结果。当你在监控对象上调用一个没有被stub的函数时并不会调用真实对象的对应函数，你不会在真实对象上看到任何效果。</p><p>因此结论就是 : 当你在监控一个真实对象时，你想在stub这个真实对象的函数，那么就是在自找麻烦。或者你根本不应该验证这些函数。</p><p><b id="14"></b></p><h2 id="14-修改没有测试桩的调用的默认返回值-1-7版本之后"><a href="#14-修改没有测试桩的调用的默认返回值-1-7版本之后" class="headerlink" title="14. 修改没有测试桩的调用的默认返回值 ( 1.7版本之后 ) "></a>14. <a href="">修改没有测试桩的调用的默认返回值 ( 1.7版本之后 )</a></h2><p>你可以指定策略来创建mock对象的返回值。这是一个高级特性，通常来说，你不需要写这样的测试。然后，它对于遗留系统来说是很有用处的。当你不需要为函数调用打桩时你可以指定一个默认的answer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Foo</span> <span class="variable">mock</span> <span class="operator">=</span> mock(Foo.class, Mockito.RETURNS_SMART_NULLS);</span><br><span class="line"><span class="type">Foo</span> <span class="variable">mockTwo</span> <span class="operator">=</span> mock(Foo.class, <span class="keyword">new</span> <span class="title class_">YourOwnAnswer</span>());</span><br></pre></td></tr></table></figure><p>关于RETURNS_SMART_NULLS更多的信息请查看 :<br><a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#RETURNS_SMART_NULLS">RETURNS_SMART_NULLS文档</a> 。</p><p><b id="15"></b></p><h2 id="15-为下一步的断言捕获参数-1-8版本之后"><a href="#15-为下一步的断言捕获参数-1-8版本之后" class="headerlink" title="15. 为下一步的断言捕获参数 (1.8版本之后)"></a>15. 为下一步的断言捕获参数 (1.8版本之后)</h2><p>Mockito以java代码风格的形式来验证参数值 : 即通过使用<code>equals()</code>函数。这也是我们推荐用于参数匹配的方式，因为这样会使得测试代码更简单、简洁。在某些情况下，当验证交互之后要检测真实的参数值时这将变得有用。例如 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);</span><br><span class="line"><span class="comment">// 参数捕获</span></span><br><span class="line">verify(mock).doSomething(argument.capture());</span><br><span class="line"><span class="comment">// 使用equal断言</span></span><br><span class="line">assertEquals(<span class="string">&quot;John&quot;</span>, argument.getValue().getName());</span><br></pre></td></tr></table></figure><p>警告 : 我们建议使用没有测试桩的ArgumentCaptor来验证，因为使用含有测试桩的ArgumentCaptor会降低测试代码的可读性，因为captor是在断言代码块之外创建的。另一个好处是它可以降低本地化的缺点，因为如果测试桩函数没有被调用，那么参数就不会被捕获。总之，ArgumentCaptor与自定义的参数匹配器相关(可以查看<a href="ArgumentMatcher">ArgumentMatcher类的文档</a> )。这两种技术都能用于检测外部传递到Mock对象的参数。然而，使用ArgumentCaptor在以下的情况下更合适 :</p><ul><li>自定义不能被重用的参数匹配器</li><li>你仅需要断言参数值</li></ul><p>自定义参数匹配器相关的资料你可以参考<a href="ArgumentMatcher">ArgumentMatcher</a>文档。</p><h2 id="16-真实的局部mocks-1-8版本之后"><a href="#16-真实的局部mocks-1-8版本之后" class="headerlink" title="16. 真实的局部mocks (1.8版本之后)"></a>16. 真实的局部mocks (1.8版本之后)</h2><p>在内部通过邮件进行了无数争辩和讨论后，最终 Mockito 决定支持部分测试，早前我们不支持是因为我们认为部分测试会让代码变得糟糕。然而，我们发现了部分测试真正合理的用法。<a target="_blank" rel="noopener" href="http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring/">详情点这</a></p><p>在 Mockito 1.8 之前，spy() 方法并不会产生真正的部分测试，而这无疑会让一些开发者困惑。更详细的内容可以看：<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#13">这里</a> 或 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spy(T">Java 文档</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//you can create partial mock with spy() method:</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> spy(<span class="keyword">new</span> <span class="title class_">LinkedList</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//you can enable partial mock capabilities selectively on mocks:</span></span><br><span class="line"><span class="type">Foo</span> <span class="variable">mock</span> <span class="operator">=</span> mock(Foo.class);</span><br><span class="line"><span class="comment">//Be sure the real implementation is &#x27;safe&#x27;.</span></span><br><span class="line"><span class="comment">//If real implementation throws exceptions or depends on specific state of the object then you&#x27;re in trouble.</span></span><br><span class="line">when(mock.someMethod()).thenCallRealMethod();</span><br></pre></td></tr></table></figure><p>一如既往，你会去读部分测试的警告部分：面向对象编程通过将抽象的复杂度拆分为一个个独立，精确的 SRPy 对象中，降低了抽象处理的复杂度。那部分测试是怎么遵循这个规范的呢？事实上部分测试并没有遵循这个规范……部分测试通常意味着抽象的复杂度被移动到同一个对象的不同方法中，在大多数情况下，这不会是你想要的应用架构方式。</p><p>然而，在一些罕见的情况下部分测试才会是易用的：处理不能轻易修改的代码（第三方接口，临时重构的遗留代码等等）。然而，为了新的，测试驱动和架构优秀的代码，我是不会使用部分测试的。</p><h2 id="17-重置mocks对象-1-8版本之后"><a href="#17-重置mocks对象-1-8版本之后" class="headerlink" title="17. 重置mocks对象 (1.8版本之后)"></a>17. 重置mocks对象 (1.8版本之后)</h2><p>聪明的 Mockito 使用者很少会用到这个特性，因为他们知道这是出现糟糕测试单元的信号。通常情况下你不会需要重设你的测试单元，只需要为每一个测试方法重新创建一个测试单元就可以了。</p><p>如果你真的想通过 reset() 方法满足某些需求的话，请考虑实现简单，小而且专注于测试方法而不是冗长，精确的测试。首先可能出现的代码异味就是测试方法中间那的 reset() 方法。这可能意味着你已经过度测试了。请遵循测试方法的呢喃：请让我们小，而且专注于单一的行为上。在 Mockito 邮件列表中就有好几个讨论是和这个有关的。</p><p>添加 reset() 方法的唯一原因就是让它能与容器注入的测试单元协作。详情看 <a target="_blank" rel="noopener" href="http://code.google.com/p/mockito/issues/detail?id=55">issue 55</a> 或 <a target="_blank" rel="noopener" href="http://code.google.com/p/mockito/wiki/FAQ">FAQ</a>。</p><p>别自己给自己找麻烦，reset() 方法在测试方法的中间确实是代码异味。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">mock</span> <span class="operator">=</span> mock(List.class);</span><br><span class="line">when(mock.size()).thenReturn(<span class="number">10</span>);</span><br><span class="line">mock.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">reset(mock);</span><br><span class="line"><span class="comment">//at this point the mock forgot any interactions &amp; stubbing</span></span><br></pre></td></tr></table></figure><h2 id="18-故障排查与验证框架的使用-1-8版本之后"><a href="#18-故障排查与验证框架的使用-1-8版本之后" class="headerlink" title="18. 故障排查与验证框架的使用 (1.8版本之后)"></a>18. 故障排查与验证框架的使用 (1.8版本之后)</h2><p>首先，如果出现了任何问题，我建议你先看 <a target="_blank" rel="noopener" href="http://code.google.com/p/mockito/wiki/FAQ">Mockito FAQ</a>。</p><p>任何你提的问题都会被提交到 Mockito 的<a target="_blank" rel="noopener" href="http://groups.google.com/group/mockito">邮件列表</a>中。</p><p>然后你应该知道 Mockito 会验证你是否始终以正确的方式使用它，对此有疑惑的话不妨看看 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#validateMockitoUsage(">validateMockitoUsage()</a>) 的文档说明。</p><h2 id="19-行为驱动开发的别名-1-8版本之后"><a href="#19-行为驱动开发的别名-1-8版本之后" class="headerlink" title="19. 行为驱动开发的别名 (1.8版本之后)"></a>19. 行为驱动开发的别名 (1.8版本之后)</h2><p>行为驱动开发实现测试单元的模式将 //given //when //then comments 视作测试方法的基础，这也是我们实现单元测试时被建议做的！</p><p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">你可以在这开始学习有关 BDD 的知识</a></p><p>问题是当信息没有很好地与 //given //when //then comments 交互时，扮演规范角色的测试桩 API 就会出现问题。这是因为测试桩属于给定测试单元的组件，而且不是任何测试的组件。因此 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/BDDMockito.html">BDDMockito</a> 类介绍了一个别名，使你的测试桩方法调用 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/BDDMockito.html#given(T">BDDMockito.given(Object)</a>) 方法。现在它可以很好地和给定的 BDD 模式的测试单元组件进行交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="type">Seller</span> <span class="variable">seller</span> <span class="operator">=</span> mock(Seller.class);</span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shop</span>(seller);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldBuyBread</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  given(seller.askForBread()).willReturn(<span class="keyword">new</span> <span class="title class_">Bread</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> shop.buyBread();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  assertThat(goods, containBread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-序列化mock对象"><a href="#20-序列化mock对象" class="headerlink" title="20. 序列化mock对象"></a>20. 序列化mock对象</h2><p>模拟对象可以被序列化。有了这个特性你就可以在依赖被序列化的情况下使用模拟对象了。</p><p>警告：这个特性很少在单元测试中被使用。</p><p>To create serializable mock use <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockSettings.html#serializable(">MockSettings.serializable()</a>):</p><p>这个特性通过 BDD 拥有不可考外部依赖的特性的具体用例实现，来自外部依赖的 Web 环境和对象会被序列化，然后在不同层之间被传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">serializableMock</span> <span class="operator">=</span> mock(List.class, withSettings().serializable());</span><br></pre></td></tr></table></figure><p>The mock can be serialized assuming all the normal <a target="_blank" rel="noopener" href="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html">serialization requirements</a> are met by the class.</p><p>模拟对象能被序列化假设所有普通的序列化要求都被类满足了。</p><p>让一个真实的侦查对象可序列化需要多一些努力，因为 spy(…) 方法没有接收 MockSettings 的重载版本。不过不用担心，你几乎不可能用到这。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">List&lt;Object&gt; spy = mock(ArrayList.class, withSettings()</span><br><span class="line">                .spiedInstance(list)</span><br><span class="line">                .defaultAnswer(CALLS_REAL_METHODS)</span><br><span class="line">                .serializable());</span><br></pre></td></tr></table></figure><h2 id="21-新的注解-Captor-Spy-InjectMocks-1-8-3版本之后"><a href="#21-新的注解-Captor-Spy-InjectMocks-1-8-3版本之后" class="headerlink" title="21. 新的注解 : @Captor,@Spy,@ InjectMocks (1.8.3版本之后)"></a>21. 新的注解 : @Captor,@Spy,@ InjectMocks (1.8.3版本之后)</h2><p>V1.8.3 带来的新注解在某些场景下可能会很实用</p><p>@<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Captor.html">Captor</a> 简化 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/ArgumentCaptor.html">ArgumentCaptor</a> 的创建 - 当需要捕获的参数是一个令人讨厌的通用类，而且你想避免编译时警告。</p><p>@<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Spy.html">Spy</a> - 你可以用它代替 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spy(T">spy(Object) 方法</a>)</p><p>@<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/InjectMocks.html">InjectMocks</a> - 自动将模拟对象或侦查域注入到被测试对象中。需要注意的是 @InjectMocks 也能与 @Spy 一起使用，这就意味着 Mockito 会注入模拟对象到测试的部分测试中。它的复杂度也是你应该使用部分测试原因。</p><p>所有新的注解仅仅在 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html#initMocks(java.lang.Object">MockitoAnnotations.initMocks(Object)</a>) 方法中被处理，就像你在 built-in runner 中使用的 @<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mock.html">Mock</a> 注解：<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html">MockitoJUnitRunner</a> 或 规范: <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoRule.html">MockitoRule</a>.</p><h2 id="22-验证超时-1-8-5版本之后"><a href="#22-验证超时-1-8-5版本之后" class="headerlink" title="22. 验证超时 (1.8.5版本之后)"></a>22. 验证超时 (1.8.5版本之后)</h2><p>允许带有暂停的验证。这使得一个验证去等待一段特定的时间，以获得想要的交互而不是如果还没有发生事件就带来的立即失败。在并发条件下的测试这会很有用。</p><p>感觉起来这个特性应该很少被使用 - 指出更好的测试多线程系统的方法。</p><p>还没有实现去和 InOrder 验证协作。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//passes when someMethod() is called within given time span</span></span><br><span class="line">verify(mock, timeout(<span class="number">100</span>)).someMethod();</span><br><span class="line"><span class="comment">//above is an alias to:</span></span><br><span class="line">verify(mock, timeout(<span class="number">100</span>).times(<span class="number">1</span>)).someMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//passes when someMethod() is called *exactly* 2 times within given time span</span></span><br><span class="line">verify(mock, timeout(<span class="number">100</span>).times(<span class="number">2</span>)).someMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//passes when someMethod() is called *at least* 2 times within given time span</span></span><br><span class="line">verify(mock, timeout(<span class="number">100</span>).atLeast(<span class="number">2</span>)).someMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//verifies someMethod() within given time span using given verification mode</span></span><br><span class="line"><span class="comment">//useful only if you have your own custom verification modes.</span></span><br><span class="line">verify(mock, <span class="keyword">new</span> <span class="title class_">Timeout</span>(<span class="number">100</span>, yourOwnVerificationMode)).someMethod();</span><br></pre></td></tr></table></figure><h2 id="23-自动初始化被-Spies-InjectMocks注解的字段以及构造函数注入-1-9-0版本之后"><a href="#23-自动初始化被-Spies-InjectMocks注解的字段以及构造函数注入-1-9-0版本之后" class="headerlink" title="23. 自动初始化被@Spies, @InjectMocks注解的字段以及构造函数注入 (1.9.0版本之后)"></a>23. 自动初始化被@Spies, @InjectMocks注解的字段以及构造函数注入 (1.9.0版本之后)</h2><p>Mockito 现在会通过注入构造方法、setter 或域注入尽可能初始化带有 @<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Spy.html">Spy</a> 和 @<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/InjectMocks.html">InjectMocks</a> 注解的域或方法。</p><p>为了利用这一点特性，你需要使用 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html#initMocks(java.lang.Object">MockitoAnnotations.initMocks(Object)</a>), <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html">MockitoJUnitRunner</a> 或 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoRule.html">MockitoRule</a>。</p><p>为了 InjectMocks 请在 Java 文档中了解更多可用的技巧和注入的规范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//instead:</span></span><br><span class="line"><span class="meta">@Spy</span> <span class="type">BeerDrinker</span> <span class="variable">drinker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeerDrinker</span>();</span><br><span class="line"><span class="comment">//you can write:</span></span><br><span class="line"><span class="meta">@Spy</span> BeerDrinker drinker;</span><br><span class="line"></span><br><span class="line"><span class="comment">//same applies to @InjectMocks annotation:</span></span><br><span class="line"><span class="meta">@InjectMocks</span> LocalPub;</span><br></pre></td></tr></table></figure><h2 id="24-单行测试桩-1-9-0版本之后"><a href="#24-单行测试桩-1-9-0版本之后" class="headerlink" title="24. 单行测试桩 (1.9.0版本之后)"></a>24. 单行测试桩 (1.9.0版本之后)</h2><p>Mockito 现在允许你在使用测试桩时创建模拟对象。基本上，它允许在一行代码中创建一个测试桩，这对保持代码的整洁很有用。举例来说，有些乏味的测试桩会被创建，并在测试初始化域时被打入，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;</span><br><span class="line">  <span class="type">Car</span> <span class="variable">boringStubbedCar</span> <span class="operator">=</span> when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span> <span class="keyword">public</span> <span class="keyword">void</span> should... &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="25-验证被忽略的测试桩-1-9-0版本之后"><a href="#25-验证被忽略的测试桩-1-9-0版本之后" class="headerlink" title="25. 验证被忽略的测试桩 (1.9.0版本之后)"></a>25. 验证被忽略的测试桩 (1.9.0版本之后)</h2><p>Mockito 现在允许为了验证无视测试桩。在与 verifyNoMoreInteractions() 方法或验证 inOrder() 方法耦合时，有些时候会很有用。帮助避免繁琐的打入测试桩调用验证 - 显然我们不会对验证测试桩感兴趣。</p><p>警告，ignoreStubs() 可能会导致 verifyNoMoreInteractions(ignoreStubs(…)) 的过度使用。谨记在心，Mockito 没有推荐用 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#verifyNoMoreInteractions(java.lang.Object...">verifyNoMoreInteractions()</a>) 方法连续地施用于每一个测试中，原因在 Java 文档中有。</p><p>一些例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">verify(mock).foo();</span><br><span class="line">verify(mockTwo).bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ignores all stubbed methods:</span></span><br><span class="line">verifyNoMoreInvocations(ignoreStubs(mock, mockTwo));</span><br><span class="line"></span><br><span class="line"><span class="comment">//creates InOrder that will ignore stubbed</span></span><br><span class="line"><span class="type">InOrder</span> <span class="variable">inOrder</span> <span class="operator">=</span> inOrder(ignoreStubs(mock, mockTwo));</span><br><span class="line">inOrder.verify(mock).foo();</span><br><span class="line">inOrder.verify(mockTwo).bar();</span><br><span class="line">inOrder.verifyNoMoreInteractions();</span><br></pre></td></tr></table></figure><p>更好的例子和更多的细节都可以在 Java 文档的 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#ignoreStubs(java.lang.Object...">ignoreStubs(Object…)</a>) 部分看到。</p><h2 id="26-mock详情-1-9-5版本之后"><a href="#26-mock详情-1-9-5版本之后" class="headerlink" title="26. mock详情 (1.9.5版本之后)"></a>26. mock详情 (1.9.5版本之后)</h2><p>为了区别一个对象是模拟对象还是侦查对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mockito.mockingDetails(someObject).isMock();</span><br><span class="line">Mockito.mockingDetails(someObject).isSpy();</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockingDetails.html#isMock(">MockingDetails.isMock()</a>) 和 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockingDetails.html#isSpy(">MockingDetails.isSpy()</a>) 方法都会返回一个布尔值。因为一个侦查对象只是模拟对象的一种变种，所以 isMock() 方法在对象是侦查对象是会返回 true。在之后的 Mockito 版本中 MockingDetails 会变得更健壮，并提供其他与模拟对象相关的有用信息，例如：调用，测试桩信息，等等……</p><h2 id="27-委托调用真实实例-Since-1-9-5"><a href="#27-委托调用真实实例-Since-1-9-5" class="headerlink" title="27. 委托调用真实实例 (Since 1.9.5)"></a>27. <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#delegating_call_to_real_instance">委托调用真实实例</a> (Since 1.9.5)</h2><p>当<strong>使用常规的 spy API 去 mock 或者 spy 一个对象很困难</strong>时可以用 delegate 来 spy 或者 mock 对象的某一部分。<br>从 Mockito 的 1.10.11 版本开始， delegate 有可能和 mock 的类型相同也可能不同。如果不是同一类型，<br>delegate 类型需要提供一个匹配方法否则就会抛出一个异常。下面是关于这个特性的一些用例:</p><ul><li>带有 interface 的 final 类</li><li>已经自定义代理的对象</li><li>带有 finalize 方法的特殊对象，就是避免重复执行。</li></ul><p>和常规 spy 的不同:</p><ul><li><p>标准的 spy <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spy(T)">(spy(Object))</a> 包含被 spy 实例的所有状态信息，方法在 spy 对象上被调用。被 spy 的对象只在 mock<br>创建时被用来拷贝状态信息。如果你通过标准 spy 调用一个方法，这个 spy 会调用其内部的其他方法记录这次操作，<br>以便后面验证使用。等效于存根 (stubbed)操作。</p></li><li><p>mock delegates 只是简单的把所有方法委托给 delegate。delegate 一直被当成它代理的方法使用。如果你<br>从一个 mock 调用它被委托的方法，它会调用其内部方法，这些调用不会被记录，stubbing 在这里也不会生效。<br>Mock 的 delegates 相对于标准的 spy 来说功能弱了很多，不过在标准 spy 不能被创建的时候很有用。</p></li></ul><p>更多信息可以看这里 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/AdditionalAnswers.html#delegatesTo(java.lang.Object)">AdditionalAnswers.delegatesTo(Object)</a>.</p><hr><h2 id="28-MockMaker-API-Since-1-9-5"><a href="#28-MockMaker-API-Since-1-9-5" class="headerlink" title="28. MockMaker API (Since 1.9.5)"></a>28. <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#mock_maker_plugin">MockMaker API</a> (Since 1.9.5)</h2><p>为了满足用户的需求和 Android 平台使用。Mockito 现在提供一个扩展点，允许替换代理生成引擎。默认情况下，Mockito 使用 cglib 创建动态代理。</p><p>这个扩展点是为想要扩展 Mockito 功能的高级用户准备的。比如，我们现在就可以在 dexmaker 的帮助下使用 Mockito<br>测试 Android。</p><p>更多的细节，原因和示例请看 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/plugins/MockMaker.html">MockMaker</a> 的文档。</p><hr><h2 id="29-new-BDD-风格的验证-Since-1-10-0"><a href="#29-new-BDD-风格的验证-Since-1-10-0" class="headerlink" title="29. (new) BDD 风格的验证 (Since 1.10.0)"></a>29. <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#BDD_behavior_verification">(new) BDD 风格的验证</a> (Since 1.10.0)</h2><p>开启 Behavior Driven Development (BDD) 风格的验证可以通过 BBD 的关键词 <strong>then</strong> 开始验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">given(dog.bark()).willReturn(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// when</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">then(person).should(times(<span class="number">2</span>)).ride(bike);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多信息请查阅 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/BDDMockito.html#then(T)">BDDMockito.then(Object)</a> .</p><hr><h2 id="30-new-Spying-或-mocking-抽象类-Since-1-10-12"><a href="#30-new-Spying-或-mocking-抽象类-Since-1-10-12" class="headerlink" title="30. (new) Spying 或 mocking 抽象类 (Since 1.10.12)"></a>30. <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spying_abstract_classes">(new) Spying 或 mocking 抽象类</a> (Since 1.10.12)</h2><p>现在可以方便的 spy 一个抽象类。注意，过度使用 spy 或许意味着代码的设计上有问题。(see <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spy(T)">spy(Object)</a>).</p><p>之前，spying 只可以用在实例对象上。而现在新的 API 可以在创建一个 mock 实例时使用构造函数。这对 mock<br>一个抽象类来说是很重要的，这样使用者就不必再提供一个抽象类的实例了。目前的话只支持无参构造函数，<br>如果你认为这样还不够的话欢迎向我们反馈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//convenience API, new overloaded spy() method:</span></span><br><span class="line"> <span class="type">SomeAbstract</span> <span class="variable">spy</span> <span class="operator">=</span> spy(SomeAbstract.class);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Robust API, via settings builder:</span></span><br><span class="line"> <span class="type">OtherAbstract</span> <span class="variable">spy</span> <span class="operator">=</span> mock(OtherAbstract.class, withSettings()</span><br><span class="line">    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Mocking a non-static inner abstract class:</span></span><br><span class="line"> <span class="type">InnerAbstract</span> <span class="variable">spy</span> <span class="operator">=</span> mock(InnerAbstract.class, withSettings()</span><br><span class="line">    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多信息请见 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockSettings.html#useConstructor()">MockSettings.useConstructor()</a> .</p><hr><h2 id="31-new-Mockito-mocks-可以通过-classloaders-序列化-反序列化-Since-1-10-0"><a href="#31-new-Mockito-mocks-可以通过-classloaders-序列化-反序列化-Since-1-10-0" class="headerlink" title="31. (new) Mockito mocks 可以通过 classloaders 序列化/反序列化 (Since 1.10.0)"></a>31. <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#serilization_across_classloader">(new) Mockito mocks 可以通过 classloaders 序列化/反序列化</a> (Since 1.10.0)</h2><p> Mockito 通过 classloader 引入序列化。和其他形式的序列化一样，所有 mock 层的对象都要被序列化，<br> 包括 answers。因为序列化模式需要大量的工作，所以这是一个可选择设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规的 serialization</span></span><br><span class="line">mock(Book.class, withSettings().serializable());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 classloaders 序列化</span></span><br><span class="line">mock(Book.class, withSettings().serializable(ACROSS_CLASSLOADERS));</span><br></pre></td></tr></table></figure><p>更多信息请查看 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockSettings.html#serializable(org.mockito.mock.SerializableMode)">MockSettings.serializable(SerializableMode)</a>.</p><hr><h2 id="32-new-Deep-stubs-更好的泛型支持-Since-1-10-0"><a href="#32-new-Deep-stubs-更好的泛型支持-Since-1-10-0" class="headerlink" title="32. (new) Deep stubs 更好的泛型支持 (Since 1.10.0)"></a>32. <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#better_generic_support_with_deep_stubs">(new) Deep stubs 更好的泛型支持</a> (Since 1.10.0)</h2><p> Deep stubbing 现在可以更好的查找类的泛型信息。这就意味着像这样的类<br> 不必去 mock 它的行为就可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lines</span> <span class="keyword">extends</span> <span class="title class_">List</span>&lt;Line&gt; &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> lines = mock(Lines.class, RETURNS_DEEP_STUBS);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Now Mockito understand this is not an Object but a Line</span></span><br><span class="line"> <span class="type">Line</span> <span class="variable">line</span> <span class="operator">=</span> lines.iterator().next();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请注意，大多数情况下 mock 返回一个 mock 对象是错误的。</p><hr><h2 id="33-new-Mockito-JUnit-rule-Since-1-10-17"><a href="#33-new-Mockito-JUnit-rule-Since-1-10-17" class="headerlink" title="33.  (new) Mockito JUnit rule (Since 1.10.17)"></a>33. <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#mockito_junit_rule">(new) Mockito JUnit rule</a> (Since 1.10.17)</h2><p>Mockito 现在提供一个 JUnit rule。目前为止，有两种方法可以初始化 fields ，使用 Mockito 提供的注解比如<br><a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Mock.html">@Mock</a>, <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/Spy.html">@Spy</a>, <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/InjectMocks.html">@InjectMocks</a> 等等。</p><ul><li>用 @RunWith(<a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html">@MockitoJUnitRunner.class</a>) 标注 JUnit 测试类</li><li>在 @Before 之前调用 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html#initMocks(java.lang.Object)">MockitoAnnotations.initMocks(Object)</a></li></ul><p>现在你可以选择使用一个 rule:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(YetAnotherRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheTest</span> &#123;</span><br><span class="line">    <span class="meta">@Rule</span> <span class="keyword">public</span> <span class="type">MockitoRule</span> <span class="variable">mockito</span> <span class="operator">=</span> MockitoJUnit.rule();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多信息到这里查看 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoJUnit.html#rule()">MockitoJUnit.rule()</a>.</p><hr><h2 id="34-new-开启和关闭-plugins-Since-1-10-15"><a href="#34-new-开启和关闭-plugins-Since-1-10-15" class="headerlink" title="34. (new) 开启和关闭 plugins (Since 1.10.15)"></a>34. <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/plugins/PluginSwitch.html">(new) 开启和关闭 plugins</a> (Since 1.10.15)</h2><p>这是一个测试特性，可以控制一个 mockito-plugin 开启或者关闭。详情请查看 <a target="_blank" rel="noopener" href="http://site.mockito.org/mockito/docs/current/org/mockito/plugins/PluginSwitch.html">PluginSwitch</a></p><hr><p>###35. 自定义验证失败信息 (Since 2.0.0)</p><p>允许声明一个在验证失败时输出的自定义消息<br>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// will print a custom message on verification failure</span></span><br><span class="line">verify(mock, description(<span class="string">&quot;This will print on failure&quot;</span>)).someMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">// will work with any verification mode</span></span><br><span class="line">verify(mock, times(<span class="number">2</span>).description(<span class="string">&quot;someMethod should be called twice&quot;</span>)).someMethod();</span><br></pre></td></tr></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>Mockito 3.6.0 中文文档</p><p><a href="http://blog.fcj.one/mockito-zh-doc.html">http://blog.fcj.one/mockito-zh-doc.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ChangingFond</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-10-28</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-04-29</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/Mockito/">Mockito</a></div></article></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/guava-primitives-Ints.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Guava 源码阅读系列——Primitives Ints 类</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/apache-https.html"><span class="level-item">利用 Let&#039;s Encrypt 配置 Apache SSL 证书</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",appId:"aW6XlFUNratBmLW8CfW2jqhS-gzGzoHsz",appKey:"7tjG9kHG4QIM8m9JjDBzVoFq",avatar:"mm",avatarForce:!1,meta:["nick","mail","link"],pageSize:10,lang:"zh-CN",visitor:!1,highlight:!0,recordIP:!1,enableQQ:!1,requiredFields:[]})</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="ChangingFond"></figure><p class="title is-size-4 is-block" style="line-height:inherit">ChangingFond</p><p class="is-size-6 is-block">fcj1021@hotmail.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">40</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">25</p></a></div></div></nav></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2022-03-03T20:15:50.000Z">2022-03-03</time></p><p class="title"><a href="/guava-primitives-Ints.html">Guava 源码阅读系列——Primitives Ints 类</a></p><p class="categories"><a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</a> / <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Guava/">Guava</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-10-28T23:32:43.000Z">2020-10-28</time></p><p class="title"><a href="/mockito-zh-doc.html">Mockito 3.6.0 中文文档</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">编程笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-11-19T12:58:24.000Z">2019-11-19</time></p><p class="title"><a href="/apache-https.html">利用 Let&#039;s Encrypt 配置 Apache SSL 证书</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-10-22T20:16:01.000Z">2019-10-22</time></p><p class="title"><a href="/hexo-travis.html">利用 Travis CI 自动部署 Hexo 博客最佳实践</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2019-07-17T14:32:12.000Z">2019-07-17</time></p><p class="title"><a href="/hexo-gulp-post.html">Hexo 博客静态资源压缩</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C#</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cuda/"><span class="tag">Cuda</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Deep-Learning/"><span class="tag">Deep Learning</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Elasticsearch/"><span class="tag">Elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Guava/"><span class="tag">Guava</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Markdown/"><span class="tag">Markdown</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mockito/"><span class="tag">Mockito</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Person-Re-ID/"><span class="tag">Person Re-ID</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ResNet/"><span class="tag">ResNet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL-Server/"><span class="tag">SQL Server</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apache/"><span class="tag">apache</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vps/"><span class="tag">vps</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87/"><span class="tag">论文</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="ChangingFond" height="28"></a><p class="is-size-7"><span>&copy; 2022 ChangingFond</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ChangingFond"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer="defer"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer="defer"></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer="defer"></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer="defer"></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer="defer"></script><script src="/js/main.js" defer="defer"></script><script src="/js/custom.js" defer="defer"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer="defer"></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"分类",tags:"标签"})})</script></body></html>